// src/index.ts
import {
  SqliteAdapter,
  SqliteIntrospector,
  SqliteQueryCompiler
} from "kysely";
var DODialect = class {
  #config;
  constructor(config) {
    this.#config = config;
  }
  createAdapter() {
    return new SqliteAdapter();
  }
  createDriver() {
    return new DODriver(this.#config);
  }
  createQueryCompiler() {
    return new SqliteQueryCompiler();
  }
  createIntrospector(db) {
    return new SqliteIntrospector(db);
  }
};
var DODriver = class {
  #config;
  constructor(config) {
    this.#config = config;
  }
  async init() {
  }
  async acquireConnection() {
    return new DOConnection(this.#config);
  }
  async beginTransaction(conn) {
    return await conn.beginTransaction();
  }
  async commitTransaction(conn) {
    return await conn.commitTransaction();
  }
  async rollbackTransaction(conn) {
    return await conn.rollbackTransaction();
  }
  async releaseConnection(_conn) {
  }
  async destroy() {
  }
};
var DOConnection = class {
  #config;
  //   #transactionClient?: DOConnection
  constructor(config) {
    this.#config = config;
  }
  async executeQuery(compiledQuery) {
    const cursor = this.#config.ctx.storage.sql.exec(compiledQuery.sql, ...compiledQuery.parameters);
    const rows = cursor.toArray();
    const numAffectedRows = cursor.rowsWritten > 0 ? BigInt(cursor.rowsWritten) : void 0;
    return {
      insertId: void 0,
      // Durable Objects doesn't provide last_row_id like D1
      rows: rows || [],
      numAffectedRows
    };
  }
  async beginTransaction() {
    throw new Error("Transactions are not supported yet.");
  }
  async commitTransaction() {
    throw new Error("Transactions are not supported yet.");
  }
  async rollbackTransaction() {
    throw new Error("Transactions are not supported yet.");
  }
  async *streamQuery(_compiledQuery, _chunkSize) {
    throw new Error("DO Driver does not support streaming");
  }
};
export {
  DODialect
};
//# sourceMappingURL=index.js.map