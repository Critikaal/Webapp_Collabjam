type ParseRoute<T extends string> = T extends `${infer Start}:${infer Param}/${infer Rest}` ? {
    [K in Param]: string;
} & ParseRoute<Rest> : T extends `${infer Start}:${infer Param}` ? {
    [K in Param]: string;
} : T extends `${infer Start}*${infer Rest}` ? {
    $0: string;
} & ParseRoute<Rest> : T extends `${infer Start}*` ? {
    $0: string;
} : {};
type LinkFunction<T extends readonly string[]> = {
    <Path extends T[number]>(path: Path, params?: ParseRoute<Path> extends Record<string, never> ? undefined : ParseRoute<Path>): string;
};
/**
 * Creates a type-safe link generation function from route patterns.
 *
 * @example
 * // Define your routes
 * const link = defineLinks([
 *   "/",
 *   "/about",
 *   "/users/:id",
 *   "/files/*",
 * ] as const)
 *
 * // Generate links with type checking
 * link("/")                                  // "/"
 * link("/about")                             // "/about"
 * link("/users/:id", { id: "123" })          // "/users/123"
 * link("/files/*", { $0: "docs/guide.pdf" }) // "/files/docs/guide.pdf"
 */
export declare function defineLinks<const T extends readonly string[]>(routes: T): LinkFunction<T>;
export {};
